package lineAnimate
import processing.core._

class RulesIR extends PApplet {
  // Current (x,y) position of the end point of the line
  var currX, currY: Float = 0
  
  def drawRules (rules: List[RulesIR]) { 
    var unitsMoved = new Array[Int](rules.size)
    var startRule = new Array[Boolean](rules.size)
    
    var i = 0
    for (i <- 1 to rules.size) {
      
    }
  }
  
  /*
   * Create conditional statements for an animation rule
   */
  def createRule (rule: RulesIR, currentRule: Int, currentStart: Boolean, listRules: List[Int], 
      listStarts : List[Boolean]) {
    //0 :: listRules        
    var currRule : Int = currentRule
    
    if(currRule < rule.positionToMove && currentStart) {
      rule.modifyPosition
      currRule+=1
    }
    if(currRule == 100) 
       false :: listStarts
  }
  
  /*
   * Shift x or y position of end point of the line
   */
  def modifyPosition(pos : Position) {
    this match {
      case Right(x) => pos.incX
      case Left(x) => pos.decX
      case Up(x) => pos.decY
      case Down(x) => pos.incY
    }
  }
  
  /*
   * Number of pixels for line to move 
   */
  def positionToMove : Float = {
    this match {
      case Right(x) => x
      case Left(x) => x
      case Up(x) => x
      case Down(x) => x
    }
  }
}

/*
 * Current position of the line
 */
case class Position (x: Int, y: Int) extends RulesIR {
  currX = x
  currY = y
  
  def incX {  currX+=1  }
  def incY {  currY+=1  }
  def decX {  currX-=1  }
  def decY {  currY-=1  }
}

/*
 * Valid rules - line can move right, left, up, or down
 */
case class Right (moveRight: Float) extends RulesIR 
case class Left (moveLeft: Float) extends RulesIR
case class Up (moveUp: Float) extends RulesIR 
case class Down (moveDown: Float) extends RulesIR 